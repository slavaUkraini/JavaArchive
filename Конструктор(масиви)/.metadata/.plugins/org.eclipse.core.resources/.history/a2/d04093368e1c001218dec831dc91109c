import java.io.IOException; 
/**
 * Class Arrays
 * Do not copy, it is my program.
 * @author Vita Krainik
 * @version 3.0 since 20.10.2012
 */
public class MyArray {
	int[] mass;
	// оли пол€ просто, а коли privat?
	
	public MyArray(int size)throws IOException {
		mass = new int[size];
		for(int i = 0; i < size; i++){
			System.out.print("¬вед≥ть " + (i + 1) + "-й елемент масиву: ");
			this.mass[i] = DataInput.getInt();//чому без this?
		}
	}	
	public MyArray (int[]a) {
		//це створенн€ ще одного такого самого масиву
		mass = new int[a.length];	
		for (int i = 0; i < a.length;i++){
			this.mass[i] = a[i];
		}	
	}
	public MyArray (MyArray massout) {
		//це створенн€ ще одного такого самого об'Їкту
		mass = new int[massout.mass.length];
		
		for (int i = 0; i < this.mass.length;i++){//поелементно чи можна було одразу увесь масив?
			this.mass[i] = massout.mass[i];
		}	
	}
	
	public void printmass () {
		/*¬ив≥д елемент≥в масиву на екран*/
		for (int i = 0; i < mass.length; i++){
			System.out.print(mass[i] + " ");
		}
		System.out.println(" ");
	}
	
	public void sortvybir () {
		//sorting
		for (int i = 0; i < mass.length; i++) {
			  int min = mass[i];
			  int imin = i; 
			  
			  for (int j = i+1; j < mass.length; j++) {
				  
				  if (mass[j] < min)
				  {
					  min = mass[j];
			          imin = j;
			          }
			    }
			    
			  if (i != imin) {
			        int temp = mass[i];
			        mass[i] = mass[imin];
			        mass[imin] = temp;
			    }
			}
		 printmass();
	}
	public void sortbulb() {
		//sorting
		for (int i = mass.length - 1; i >= 2; i--) {
			  boolean sorted = true;
			  for (int j = 0; j < i; j++) {
				  if (mass[j] > mass[j+1]) {
					  int temp = mass[j];
					  mass[j] = mass[j+1];
					  mass[j+1] = temp;
			          sorted = false;
			          }
			    }
			  if (sorted) {
				  break;
			    }
			}
		  printmass();
	}
	public void sortvstavka() {
		//sorting 
		for (int i = 2;  i <= mass.length; i++) 
		{
			    int t = mass[i]; //запам'€товуЇмо в≥дсортований елемент
			    int j = 1; //≥ндекс шуканого м≥сц€ дл€ наступного числа
			    while (t > mass[j]){ j = j + 1;} //поки в≥дсортований елемент б≥льший за
			                 //не в≥дсортований, переходимо до наступного елементу вправо}
			    for (int k = i - 1; k>=j; k--){ //{коли знайшли м≥сце дл€ не в≥дсортованого ел --}
			      mass[k + 1] = mass[k]; }      // {--пересуваЇмо його вл≥во на потр≥бний ≥ндекс}
			    mass[j] = t;
			    }

			  }
			 }
}